from pathlib import Path
import os
import subprocess
import hashlib
import re
import mingpy.ming_sc as sc
from mythril.disassembler import asm
from web3 import Web3
import json
import gc

cache_path = ""

# Read nas_cache_path from system environment
NAS_CACHE_PATH = os.environ.get('NAS_CACHE_PATH', '/tmp')

def set_cache_path(path):
    global cache_path
    cache_path = path

def load_mythril_call_cache(hash):
    """
    Load the cache file from the cache path
    """
    global cache_path
    cache_folder = Path(NAS_CACHE_PATH) / "mythril" / hash / "CallTransfer"

    result = []

    if cache_folder.exists():
        # The folder is filled with json files, read them all adn return
        result = []
        for file in cache_folder.iterdir():
            with open(file, 'r') as f:
                result.append(json.load(f))

    return result

# Use mythril to analyze the contract.
# We only need hexcode of the contract prepared cuz
# I dnt think mythril could handel the decompiled code generated by panoramix

def mythril_get_direct_call_targets_from_hex_code(code) -> list : 
    """
    Use Mythril to get all direct call targets given the hex code
    """
    
    call_targets = set()

    # Check the cache first
    hash = hashlib.sha256(code.encode('utf-8')).hexdigest()
    output = load_mythril_call_cache(hash)

    # If we cant find output
    if not output:
        # Run myth system command and capture the json output
        # Get the absolute path of the mythril/modules folder
        target_cache_folder = Path(NAS_CACHE_PATH) / "mythril" / hash
        modules_path = Path(__file__).parent.parent / "mythril" / "modules"
        proc = subprocess.run(["myth", "analyze", "-c", code, "--bin-runtime", "--custom-modules-directory", str(modules_path.absolute()) ,"--modules", "CallTargetAnalysis", "-o", "json", "--unconstrained-storage", "-e", str(target_cache_folder), '--parallel-solving'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        # Get the error output and save it to the error folder on the local system
        error_output = proc.stderr.decode('utf-8')
        if error_output:
            # Open the error txt in home folder and append to it
            with open("error.txt", 'a') as f:
                f.write(f"{code}: {error_output}")

    # Now try to load the cache again
    output = load_mythril_call_cache(hash)
    
    # If it is still empyt, then we failed, return
    if not output:
        return list(call_targets)

    
    # Otherwise, go thourgh each transfor record in the result
    for callTransfer in output:
        # Get the callee
        if callTransfer['to_symbolic']:
            # We could only get the expression if it is symbolic
            callee = callTransfer['to_sexpr']

        else:
            callee = callTransfer['to_value']

        call_targets.add(callee)

    return list(call_targets)

def mythril_get_direct_call_targets_from_contract(contract):
    """
    Get all direct call targets given the contract address
    """

    # First set the cache path of ming_sc component
    sc.set_cache_path(NAS_CACHE_PATH)

    # Use sc to get the hex code of the contract
    hex_code = sc.infura_get_contract_hex_code(os.environ['INFURA_PROJECT_ID'], contract)

    if not hex_code:
        raise Exception("Failed to get the hex code of the contract using infura")

    hex_code = hex_code.strip()

    return mythril_get_direct_call_targets_from_hex_code(hex_code)

def load_cache(hash):
    """
    Load the cache file from the cache path
    """
    global cache_path
    cache_file = Path(cache_path) / hash
    if cache_file.is_file():
        with open(cache_file, 'r') as f:
            return f.read()
    else:
        return None

def save_cache(hash, content):
    """
    Save the decompiled code to the cache path
    """
    global cache_path
    with open(Path(cache_path) / hash, 'w') as f:
        f.write(content)

def panoramix_decompile_hex_code_raw(code):
    """
    Get the direct decompiled results from panoramix with --explain flag
    """

    # Get the sha256 hash of the hex code
    hash = hashlib.sha256(code.encode('utf-8')).hexdigest()

    # Check if the file is already decompiled
    decompile_code_raw = load_cache(hash)

    # if not, decompile it
    if decompile_code_raw is None:
        # Run panoramix
        decompile_code_raw = subprocess.check_output(["panoramix", code, "--explain"]).decode('utf-8')

        if not decompile_code_raw:
            raise Exception("Panoramix failed to decompile the code")

        # remove all color codes
        color_code_pattern = r'\x1B\[[0-9;]*[A-Za-z]'
        decompile_code_raw = re.sub(color_code_pattern, '', decompile_code_raw)

        # Save the decompiled code to the cache
        save_cache(hash, decompile_code_raw)
        with open(Path(cache_path) / hash, 'w') as f:
            f.write(decompile_code_raw)

    return decompile_code_raw

def panoramix_decompile_contract_raw(contract):
    """
    Get the direct decompiled results from panoramix with --explain flag given the contract
    """

    # First set the cache path of ming_sc component
    sc.set_cache_path(NAS_CACHE_PATH)

    # Use sc to get the hex code of the contract
    hex_code = sc.infura_get_contract_hex_code(os.environ['INFURA_PROJECT_ID'], contract)

    if not hex_code:
        raise Exception("Failed to get the hex code of the contract using infura")

    hex_code = hex_code.strip()

    # Use panoramix to decompile the hex code
    return panoramix_decompile_hex_code_raw(hex_code)

def divide_panoramix_decompile_code(decompile_code_raw):
    # decompile_code_raw includes both analysis process output and the final decompiler result, we want to separate these two
    # Try to find '# Palkeoramix decompiler.' in the text as the divider. It is possible that the decompiler result is empty
    divider = '# Palkeoramix decompiler.'
    divider_index = decompile_code_raw.find(divider)
    if divider_index == -1:
        return [decompile_code_raw, '']
    else:
        return [decompile_code_raw[:divider_index], decompile_code_raw[divider_index:]]

def panoramix_get_all_call_targets_from_decompiled_code(decompile_code_raw):
    # decompile_code_raw includes both analysis process output and the final decompiler result, we want to separate these two
    # We want to find call_targets from both analysis and decompiler result

    res = {
            "panoramix_analysis": [],
            "panoramix_decompiler": [],
            }

    # First divide the decompile_code_raw into two parts
    [analysis_result, decompile_result] = divide_panoramix_decompile_code(decompile_code_raw)

    # For analysis_result, we go broad to find all eth adderss
    if analysis_result:
        eth_addresses = sc.match_eth_account(analysis_result)
        res["panoramix_analysis"] = list(set(eth_addresses))

    if decompile_result:
        # Get all the call targets
        pattern = r"\bcall\s+(\S+)\s+with"

        # Find all targets using the pattern
        call_targets = re.findall(pattern, decompile_code_raw)
        res["panoramix_decompiler"] = list(set(list(call_targets)))

    return res

def panoramix_get_all_call_targets_from_hex_code(code):
    '''
    Get all the call targets from the hex code
    '''

    # use panoramix
    # Get the direct decompiled results from panoramix with --explain flag
    decompile_code_raw = panoramix_decompile_hex_code_raw(code)

    return panoramix_get_all_call_targets_from_decompiled_code(decompile_code_raw)


def get_all_call_targets_from_contract(contract):
    '''
    Get all the call targets from the contract
    '''

    call_targets = {}

    # use panoramix
    # First decompile the contract
    decompile_code_raw = panoramix_decompile_contract_raw(contract)
    panoramix_call_targets = panoramix_get_all_call_targets_from_decompiled_code(decompile_code_raw)

    call_targets['panoramix'] = panoramix_call_targets

    # use mythril
    mythril_call_targets = mythril_get_direct_call_targets_from_contract(contract)

    call_targets['mythril'] = mythril_call_targets

    return call_targets
